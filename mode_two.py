# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-GHanZ5xLZ_7RxW96t0sGCQVTYCzGR_l
"""

class TicTacToe:
    def __init__(self):
        self.board = [" ", " ", " ",
                      " ", " ", " ",
                      " ", " ", " "]
        self.current_player = "X"

    def show(self):
        """Format and print board"""
        print("""
          {} | {} | {}
         -----------
          {} | {} | {}
         -----------
          {} | {} | {}
        """.format(*self.board))

    def clear_board(self):
        """Clear the board"""
        for i in range(len(self.board)):
            self.board[i] = " "

    def available_moves(self):
        """Return empty spaces on the board"""
        moves = []
        for i in range(len(self.board)):
            if self.board[i] == " ":
                moves.append(i)
        return moves

    def get_moves(self, player):
        """Get all moves made by a given player"""
        moves = []
        for i in range(len(self.board)):
            if self.board[i] == player:
                moves.append(i)
        return moves

    def make_move(self, position, player):
        """Make a move on the board"""
        if self.board[position] == " ":
            self.board[position] = player
            return True
        else:
            print("Invalid Move")
            return False

    def check_win(self):
        """Return the player that wins the game"""
        combos = ([0, 1, 2], [3, 4, 5], [6, 7, 8],
                  [0, 3, 6], [1, 4, 7], [2, 5, 8],
                  [0, 4, 8], [2, 4, 6])

        for player in ("X", "O"):
            positions = self.get_moves(player)
            for combo in combos:
                win = True
                for pos in combo:
                    if pos not in positions:
                        win = False
                if win:
                    return player

    def game_over(self):
        """Return True if X wins, O wins, or draw, else return False"""
        if self.check_win() is not None:
            if self.check_win()=="X":
                print("Congrats!! you won")
            else:
                print("You lost!!")
            return True
        for i in self.board:
            if i == " ":
                return False
        return True

    def minimax(self, depth, player):
        if player == "O":
            best = [-1, -float( "inf" )]  # [move, score]
        else:
            best = [-1, float("inf")]  # [move, score]

        if depth == 0 or self.game_over():
            score = self.evaluate()
            return [-1, score]

        for move in self.available_moves():
            self.board[move] = player

            if self.check_win() == "O":
                score = [move, 1]  # Assign a winning score for "O"
            elif self.check_win() == "X":
                score = [move, -1]  # Assign a losing score for "X"
            else:
                score = self.minimax(depth - 1, self.change_player(player))
                score[0] = move

            self.board[move] = " "  # Undo the move

            if player == "O":
                if score[1] >= best[1]:
                    best = score  # Maximize the score
            else:
                if score[1] <= best[1]:
                    best = score  # Minimize the score
            if player == "O" and score[1] == 1 and self.check_win()=="O":
            # If the current player is "O" and the score is 1 (winning move), return immediately
             return score

        return best

    def evaluate(self):
        winner = self.check_win()
        if winner == "O":
            return 1
        elif winner == "X":
            return -1
        else:
            return 0

    def make_best_move(self, depth, player):
        """
        Controller function to initialize minimax and keep track of optimal move choices
        depth - how far down the tree to go
        player - who to calculate the best move for (Works ONLY for "O" right now)
        """
        best_move = self.minimax(depth, player)[0]
        return best_move

    def change_player(self, player):
        """Returns the opposite player given any player"""
        if player == "X":
            return "O"
        else:
            return "X"

    def play_game(self):
        self.clear_board()
        self.show()

        while not self.game_over():

            isValid = False
            while not isValid:
                person_move = int(input("You are X: Choose a number from 1-9: "))
                isValid = self.make_move(person_move - 1, "X")
            self.show()

            if self.game_over():
                break

            print("Computer choosing move...")
            ai_move = self.make_best_move(-1, "O")
            self.make_move(ai_move, "O")
            self.show()


